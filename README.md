# Run_pe_cryptor_frame

Обсудить проект на форуме и связаться с автором можно здесь:https://ru-sfera.org/threads/frejmvork-kriptora-protektora-s-antiehmuljaciej.3809/

**Фреймворк криптора/протектора с антиэмуляцией**

**Что это за проект и зачем он нужен ?**

На самом деле много людей интересуется протекторами и вирусными технологиями. 
Кто-то хочет заработать, кто-то хочет повысить скилл в кодинге, кому-то просто это нравится и считается, что это своего вроде исскуство.)

Тем не менее, с момента основания ресурса ru-sfera.org, люди пишут мне с вопросами, хорошо-бы если был-бы какой-то проект, так-сказать каркас, что-то взять за основу.
Да, есть готовые проекты, но они либо устарели, либо имеют слишком сложную структуру, либо имеют существенные недостатки, об этом ниже. 

Так-как неизвестно-кто будет этим проектом пользоваться и кто прочитает эту статью, начнем с небольшего ликбеза.)

**Что-же такое крипторы, их будущее и зачем они нужны ?** 

Очень нравится, что про это дело говорил Вазонез (До ухода в реал):

**Криптор (aka cryptor)** — это тулза, которая предназначена для скрытия троянов, ботов и прочей нечисти от детектирования антивирусами. 

**Крипторы можно разделить на 2 вида: хорошие и дерьмовые:** 

Хорошие крипторы работают очень просто, быстро и надёжно, **хоть и не безглючно.** Они дописывают свой код (в контексте таких крипторов этот код называется стабом) в криптуемую программу и шифруют код самой 
программы. 

При запуске первым стартует стаб, он восстанавливает оригинальный код и программа начинает работать. Если криптор свежий (или просто хороший, об этом ниже), то закриптованная программа не будет детектироваться 
антивирусами.

**Чаще всего такие крипторы полиморфны** — т.е. код криптора в криптуемой программе каждый раз уникален, заполнен случайными инструкциями и бессмысленными вызовами функций API. Такие крипторы достаточно долго 
остаются недетектируемыми в силу уникальности каждого закриптованного файла. 

Но, как говорится, на каждую хитрую жопу найдется х** с винтом — такие крипторы тоже со временем детектируются, и если автор не чистит свой продукт, то криптор перестает быть уникальным и посылается нах**.

Другим же типом крипторов являются стабовые крипторы. Вообще только дебил будет называть это криптором, но в силу еб*** и многочисленности авторов таких творений, мы не будем отрываться от стаи.

Итак, быдлокрипторы. Суть их работы вот в чем — есть стаб. Стаб в этом случае — это отдельная программа, к которой цепляется криптуемый файл. При запуске файл извлекается, расшифровывается и запускается.

**Думаю с этим всё понятно, каково-же будущее крипторов ?**

Антивирусы эволюционируют, появились новые технологие защиты (А именно детекты по поведению, детекты по репутации и т.д.), в частноти против крипторов появилась технология сканирования процессов, если вкратце, то 
антивирус либо сразу перед созданием процесса, либо через какое-то время сканирует процесс.

Тем самым понятно, даже если обойти эмулятор антивируса и сигнатурный детект, мы попадем под детект процесса.

**Что делать ?**

Менять технологию скрытия детекта, вот следующие решения:

1. Шифровать и скрывать критичные функции в коде (Например шеллы и т.д.), после расшифровки и запуска такой функции, если использовать антиэмуляцию, антивирус ничего сделать несможет.)

2. Морфить код, если вкратце, это самомодификация кода на лету (Данный метод реализован в этом крипторе).

3.Первые два способа, это если у вас есть исходник, что-же делать если исходника нет. Неужели крипторы умерли ?

Честно я так и думал, до недавнего времени, но это несовсем так:

- Во первых если у вас есть даже зверек без детекта, его неплохо-бы скрыть от реверсера, к тому-же почти все детектится сейчас автоматикой, в таком случае в большинстве случаев робот задетектит сам криптор, по хешу, 
или не по хешу, но чем сложнее будет реверсеру, тем больше вероятность, что сам троянчик будет дольше жить.

- Во вторых не все антивирусы детектят код в памяти, например виндовый дефендер как-то криво с этим работает.

- Некоторые антивирусы дают запустить процесс на пару секунд, а этого и может хватит кстати.)))

**С лекбезом закончили, на форуме есть темы для глубокого изучения вопроса:**

https://ru-sfera.org/threads/eschjo-raz-pro-dzhojnery-kriptory-staby-i-prochuju-xren.1566/

https://ru-sfera.org/threads/uchimsja-obxodit-detekt-antivirusov-chast-1.3279/

https://ru-sfera.org/threads/uchimsja-obxodit-detekt-antivirusov-chast-2-vnedrenie-behkdora-v-pe-fajl.3280/

https://ru-sfera.org/threads/ehmuljacija-antiehmuljacija-detekt-i-kriptory.3612/

Хороший раздел с разными статьями:https://ru-sfera.org/forums/texnologii-sozdanija-nevidimoj-malvari.156/

**Теперь про конкретный проект, что он делает:**

Думал я что-бы такое сделать, просто стабовые крипторы, как описано выше смысла делать нет, через какое-то время будет детект стаба и смысл ?

Поэтому решил я сделать проект, где-бы сам криптованный зверек размещался-бы в дата-секции, т.е. есть программа (я назвал её shell_gen), которая из бинарного файла, делает пошифрованный массив байт и в общем-то 
больше ничего не делает.)

Далее уже второй проект (Сам криптор), работает с этим массивом данных, т.е. расшифровывает этот массив, делает антиэмуляцию, запускает.

Для достижения метаморфизма, shell_gen генерирует заголовочный файл, со следующими дефайнами:

#define START_MORPH_CODE 5

#define END_MORPH_CODE 14

На основе этих значений при сборки, генерируется "мусорный код" (Математичесие операции и т.д.), который будет случайным, после каждого вызова shell_gen и сборки.

Тем самым код будет разный, как по коду, так и по данным.

**Сам криптор (x86_pe_cryptor) имеет модульную структуру:**

**1)modules/lazy_importer/**

Модуль скрытия API из таблицы импорта. Пример использования:

auto base = reinterpret_cast<std::uintptr_t>(LI_FIND(LoadLibraryA)(kernel32));

LI_GET(base, VirtualFree)(pFile, 0, MEM_RELEASE);

**2)modules/murmurhash/**

Реализация вычисления хеша murmurhash на ассемблере (FASM, приложен к проекту).

**3)modules/trash_gen_module/**

Реализация модуля, для генерация случайных инструкций, генерации случаных API винды и получение случайного числа на ассемблере (FASM, приложен к проекту), более подробное описание здесь:https://github.com/XShar/simple_trashe_gen_module

**4)modules/xtea/**

Реализация алгоритма шифрование xtea на ассемблере (FASM, приложен к проекту).

**5)modules/run_pe/**

Реализация функции запуска, расшифрованного массива PE-файла в памяти, путем создания процесса.

**6)modules/antiemul/**

Функции антиэмуляции.

**7)modules/metamorph_code/**

Функции метаморфинга. Смысл, что при сборки, генерируются функции в случайном порядке, функции берутся в modules/metamorph_code/morph.cpp.

**8)modules/simple_mutate_pe/**

Функции мутации PE перед запуском.

**Характеристики получившегося криптора:**

1)Отстутствуют "опасные API" в таблице импорта (Такие-как CreateProcess и т.д.).

2)Имеет антиэмуляцию, направленную на привышение лимитов эмулятора антивирусов:

- Выделение памяти 32 мегабайт, копирование туда нашего зверька, потом подсчет хеша этого куска памяти, шифровка/расшифровка этого куска памяти, в качестве ключа наш хеш.Эта-же память используется для размещения запуска зверька.

- Получение ключа для расшифровки, следующим образом:

Генерируется массив случаных чисел от 0 до 9, далее генерируется хеш этих чисел, хеш генерируется на основе числа, сгенерированного при создании зашифрованного массива защищаемого файла.
Далее сортируется массив от 0 до 9, т.е. в итоге у нас получается хеши от числел 0-9. Отсортированные по порядку, это и будет ключ.
В момент генерации ключа, также в случайном порядке генерируется мусор из случайных инструкций и вызовов API.

- Все строки зашифрованы, перед расшифровкой строк,происходит задержка 1 секунду, далее по меткам времени происходит вычисление, действительно-ли была задержка секунду.
Если да, то на основе этого вычисляется размер ключа:size_key = (mesure2.wSecond - mesure1.wSecond) + 3.
Если sleep был пропущен, то размер ключа будет неверный и расшифровка будет неправильна.

3)При сборки, в main и в модулях:modules/run_pe/, modules/trash_gen_module/ генерируются функции в случайном порядке, функции берутся в modules/metamorph_code/morph.cpp (На данный момент там функции арифметических операций).
Тем самым достигается полиморфность не только данных, но и кода каждого образца.)))

4)Перед запуском происходит мутация запускаемого PE, что позволяет обойти детект в памяти у некоторых антивирусов. 

**Как работать с криптором:**

Есть два проекта в Visual Studio 2017 или более новой:

1)shell_gen - Генерирует массив зашифрованных байт, файл /modules/data_protect.h.

2)x86_pe_cryptor - Сам криптор.

Для работы необходимо сделать следующее:

1.Переименовать защищаемый файл в "data_protect.exe" и поместить его в shell_gen/Release/

2.Запустить файл shell_gen/Release/shell_gen.exe

3.Собрать проект x86_pe_cryptor в Visual Studio 2017 или более новой.

Всё, в /x86_pe_cryptor/Release/x86_pe_cryptor.exe будет сам криптор.)))

Проект будет обновляться, что планируется:

1)Сделать для x64 (https://github.com/XShar/Run_pe_cryptor_x64).

2)Рефакторинг кода.

3)Что-то ещё, в зависимости от активности на форуме.)))

В исходнике есть пример, запуск putty.exe:

/x86_pe_cryptor/Release/x86_pe_cryptor.exe

И:

/shell_gen/Release
